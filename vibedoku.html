<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vibedoku - Emoji Sudoku Challenge</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .container {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 600px;
        }
        @media (max-width: 600px) {
            body {
                padding: 5px;
            }
            .container {
                padding: 10px;
            }
        }
        h1 {
            text-align: center;
            color: #5a67d8;
            margin-bottom: 10px;
            font-size: clamp(24px, 5vw, 36px);
        }
        .tagline {
            text-align: center;
            color: #718096;
            margin-bottom: 20px;
            font-style: italic;
        }
        .emoji-legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
            padding: 15px;
            background: #f7fafc;
            border-radius: 10px;
        }
        .emoji-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 20px;
        }
        .emoji-item span {
            font-size: 24px;
        }
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            gap: 1px;
            background-color: #4a5568;
            padding: 3px 1px 1px 3px;
            margin: 15px auto;
            width: calc(100vw - 40px);
            max-width: 450px;
            aspect-ratio: 1 / 1;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            border-radius: 10px;
            overflow: hidden;
        }
        @media (max-width: 600px) {
            .sudoku-grid {
                width: calc(100vw - 20px);
                margin: 10px auto;
            }
        }
        .cell {
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(16px, 4vw, 24px);
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            user-select: none;
        }
        .cell * {
            pointer-events: none;
        }
        .cell:hover:not(.given) {
            background-color: #edf2f7;
            transform: scale(1.05);
        }
        .cell.given {
            background-color: #e2e8f0;
            cursor: default;
        }
        .cell.user-input {
            background-color: #f7fafc;
        }
        .cell.hint-used {
            background-color: #fff5f5;
        }
        .cell.auto-filled {
            animation: glow 0.5s;
        }
        .cell:nth-child(3n) {
            border-right: 3px solid #4a5568;
        }
        .cell:nth-child(n+19):nth-child(-n+27),
        .cell:nth-child(n+46):nth-child(-n+54),
        .cell:nth-child(n+73):nth-child(-n+81) {
            border-bottom: 3px solid #4a5568;
        }
        /* Rounded corners for edge cells */
        .cell:nth-child(1) {
            border-top-left-radius: 8px;
        }
        .cell:nth-child(9) {
            border-top-right-radius: 8px;
        }
        .cell:nth-child(73) {
            border-bottom-left-radius: 8px;
        }
        .cell:nth-child(81) {
            border-bottom-right-radius: 8px;
        }
        .cell.notes {
            font-size: clamp(6px, 1.2vw, 9.2px) !important;
            display: grid !important;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 0;
            align-items: center;
            justify-items: center;
            gap: 0;
        }
        .cell.notes.notes-hidden > div {
            visibility: hidden;
        }
        .cell.notes > div {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        @keyframes glow {
            0% { box-shadow: 0 0 5px #48bb78; }
            50% { box-shadow: 0 0 20px #48bb78, 0 0 30px #48bb78; }
            100% { box-shadow: 0 0 5px #48bb78; }
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .stat-item {
            text-align: center;
            padding: 10px 20px;
            background: #f7fafc;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .stat-label {
            color: #718096;
            font-size: 14px;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #5a67d8;
        }
        .hint-count {
            color: #e53e3e;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            background: #5a67d8;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        button:hover {
            background: #4c51bf;
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .new-game-btn {
            background: #48bb78;
        }
        .new-game-btn:hover {
            background: #38a169;
        }
        .timer {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            color: #4a5568;
            margin: 15px 0;
        }
        .helper-status {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .helper-badge {
            padding: 5px 10px;
            background: #48bb78;
            color: white;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .helper-badge::before {
            content: '✓';
            font-weight: bold;
        }
        .instructions {
            text-align: center;
            color: #718096;
            margin: 20px 0;
            font-size: 14px;
            line-height: 1.6;
        }
        .score-display {
            text-align: center;
            font-size: 36px;
            font-weight: bold;
            margin: 20px 0;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .completion-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            text-align: center;
            z-index: 1000;
        }
        .completion-modal.show {
            display: block;
            animation: bounceIn 0.5s;
        }
        @keyframes bounceIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        .modal-overlay.show {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎮 Vibedoku 🎮</h1>
        <p class="tagline">The fewer hints you use, the higher your vibe! 🌟</p>
        

        <div class="stats">
            <div class="stat-item">
                <div class="stat-label">Hints Used</div>
                <div class="stat-value hint-count" id="hintCount">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Score</div>
                <div class="stat-value" id="score">1000</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Time</div>
                <div class="stat-value" id="timer">00:00</div>
            </div>
        </div>

        <div class="sudoku-grid" id="grid"></div>


        <div class="controls">
            <button class="new-game-btn" onclick="newGame()">New Vibedoku 🎲</button>
            <button onclick="toggleNotesVisibility()" id="notesToggle">Hide Notes 🙈</button>
        </div>

        <div class="instructions">
            💡 Click any cell to reveal the emoji<br>
            🎯 Goal: Complete the puzzle using as few clicks as possible
        </div>
    </div>

    <div class="modal-overlay" id="modalOverlay" onclick="closeModal()"></div>
    <div class="completion-modal" id="completionModal">
        <h2>🎉 Vibedoku Complete! 🎉</h2>
        <div class="score-display" id="finalScore">0</div>
        <p>You used <strong id="finalHints">0</strong> hints</p>
        <p id="scoreMessage"></p>
        <button class="new-game-btn" onclick="newGame()">Play Again 🎮</button>
    </div>

    <script>
        // Emoji pools for different vibes
        const emojiPools = {
            animals: ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐨', '🐯', '🦁', '🐮', '🐷', '🐸', '🐵'],
            food: ['🍎', '🍊', '🍋', '🍌', '🍉', '🍇', '🍓', '🫐', '🍈', '🍒', '🍑', '🥭', '🍍', '🥥', '🥝'],
            nature: ['🌸', '🌺', '🌻', '🌹', '🌷', '🌲', '🌳', '🌴', '🌵', '🌾', '🌿', '☘️', '🍀', '🍁', '🍄'],
            space: ['🌟', '⭐', '🌙', '☀️', '🌤️', '⛅', '☁️', '🌈', '🌠', '💫', '✨', '🌍', '🪐', '🛸', '🚀'],
            hearts: ['❤️', '🧡', '💛', '💚', '💙', '💜', '🖤', '🤍', '🤎', '💗', '💖', '💕', '💞', '💓', '💘'],
            faces: ['😀', '😃', '😄', '😁', '😆', '😊', '😇', '🙂', '😉', '😌', '😍', '🥰', '😘', '😗', '😙']
        };

        // Game state
        let currentEmojis = [];
        let emojiToNumber = {};
        let numberToEmoji = {};
        let grid = [];
        let solution = [];
        let gameGrid = [];
        let hintsUsed = 0;
        let score = 1000;
        let startTime = null;
        let timerInterval = null;
        let isComplete = false;

        // Helper states (always on)
        const helpers = {
            autoNotes: true,
            autoFillSingles: true,
            autoFillHidden: true,
            autoRemoveLocked: true
        };
        
        // UI states
        let notesVisible = true;

        // Animation speeds
        const animationDuration = 300;
        const intervalDuration = 200;

        // Initialize game
        function initGame() {
            console.log('🎮 Initializing Vibedoku...');
            selectRandomEmojis();
            createGrid();
            generatePuzzle();
            displayEmptyGrid(); // Start with all cells empty like minesweeper
            startTimer();
            initializeAutoNotes();
        }

        // Select 9 random emojis from a random pool
        function selectRandomEmojis() {
            const poolNames = Object.keys(emojiPools);
            const selectedPool = poolNames[Math.floor(Math.random() * poolNames.length)];
            const pool = emojiPools[selectedPool];
            
            // Shuffle and pick 9
            const shuffled = [...pool].sort(() => Math.random() - 0.5);
            currentEmojis = shuffled.slice(0, 9);
            
            // Create mappings
            emojiToNumber = {};
            numberToEmoji = {};
            currentEmojis.forEach((emoji, index) => {
                emojiToNumber[emoji] = index + 1;
                numberToEmoji[index + 1] = emoji;
            });
            
            console.log('🎨 Selected emoji theme:', selectedPool);
            console.log('📝 Emoji mapping:', numberToEmoji);
            
            // No legend displayed anymore
        }

        // Create grid elements
        function createGrid() {
            const gridElement = document.getElementById('grid');
            gridElement.innerHTML = '';
            
            for (let i = 0; i < 81; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.index = i;
                cell.addEventListener('click', onCellClick);
                gridElement.appendChild(cell);
            }
        }

        // Generate a simple puzzle
        function generatePuzzle() {
            console.log('🧩 Generating puzzle...');
            
            // First generate a complete solution
            solution = generateCompleteSolution();
            
            // Create empty grid for minesweeper style
            grid = Array(9).fill(null).map(() => Array(9).fill(0));
            
            // Initialize game grid - all cells start empty
            gameGrid = [];
            for (let r = 0; r < 9; r++) {
                gameGrid[r] = [];
                for (let c = 0; c < 9; c++) {
                    gameGrid[r][c] = {
                        value: 0,
                        given: false,
                        notes: new Set(),
                        hintUsed: false,
                        revealed: false
                    };
                }
            }
            
            console.log('📊 Generated empty puzzle with hidden solution');
        }

        // Generate complete solution
        function generateCompleteSolution() {
            const board = Array(9).fill(null).map(() => Array(9).fill(0));
            
            // Fill diagonal boxes first (they don't interfere with each other)
            for (let box = 0; box < 9; box += 3) {
                fillBox(board, box, box);
            }
            
            // Solve the rest
            solveSudoku(board, 0, 0);
            return board;
        }

        // Fill a 3x3 box with random numbers
        function fillBox(board, startRow, startCol) {
            const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const idx = Math.floor(Math.random() * nums.length);
                    board[startRow + i][startCol + j] = nums[idx];
                    nums.splice(idx, 1);
                }
            }
        }

        // Sudoku solver
        function solveSudoku(board, row = 0, col = 0) {
            if (col === 9) {
                row++;
                col = 0;
            }
            if (row === 9) return true;
            
            if (board[row][col] !== 0) {
                return solveSudoku(board, row, col + 1);
            }
            
            const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5);
            
            for (let num of nums) {
                if (isValidPlacement(board, row, col, num)) {
                    board[row][col] = num;
                    if (solveSudoku(board, row, col + 1)) return true;
                    board[row][col] = 0;
                }
            }
            
            return false;
        }

        // Check if placement is valid
        function isValidPlacement(board, row, col, num) {
            // Check row
            for (let x = 0; x < 9; x++) {
                if (board[row][x] === num) return false;
            }
            
            // Check column
            for (let x = 0; x < 9; x++) {
                if (board[x][col] === num) return false;
            }
            
            // Check 3x3 box
            const boxRow = Math.floor(row / 3) * 3;
            const boxCol = Math.floor(col / 3) * 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (board[boxRow + i][boxCol + j] === num) return false;
                }
            }
            
            return true;
        }


        // Display empty grid (minesweeper style)
        function displayEmptyGrid() {
            const cells = document.querySelectorAll('.cell');
            
            cells.forEach((cell, index) => {
                cell.className = 'cell';
                cell.textContent = '';
                cell.style.backgroundColor = '#e2e8f0'; // Gray like unrevealed minesweeper cells
            });
        }

        // Display puzzle on grid
        function displayPuzzle() {
            const cells = document.querySelectorAll('.cell');
            
            cells.forEach((cell, index) => {
                const row = Math.floor(index / 9);
                const col = index % 9;
                const data = gameGrid[row][col];
                
                cell.className = 'cell';
                cell.textContent = '';
                
                if (data.given) {
                    cell.textContent = numberToEmoji[data.value];
                    cell.classList.add('given');
                } else if (data.value !== 0) {
                    cell.textContent = numberToEmoji[data.value];
                    cell.classList.add('user-input');
                    if (data.hintUsed) {
                        cell.classList.add('hint-used');
                    }
                } else if (data.notes.size > 0) {
                    updateCellDisplay(cell, row, col);
                }
            });
        }

        // Update cell display for notes
        function updateCellDisplay(cell, row, col) {
            const data = gameGrid[row][col];
            
            if (data.notes.size > 0 && data.value === 0) {
                cell.innerHTML = '';
                cell.classList.add('notes');
                if (!notesVisible) {
                    cell.classList.add('notes-hidden');
                } else {
                    cell.classList.remove('notes-hidden');
                }
                for (let i = 1; i <= 9; i++) {
                    const noteDiv = document.createElement('div');
                    if (data.notes.has(i)) {
                        noteDiv.textContent = numberToEmoji[i];
                    }
                    cell.appendChild(noteDiv);
                }
            } else {
                cell.classList.remove('notes', 'notes-hidden');
                cell.innerHTML = '';
                if (data.value) {
                    cell.textContent = numberToEmoji[data.value];
                }
            }
        }
        
        // Toggle notes visibility
        function toggleNotesVisibility() {
            notesVisible = !notesVisible;
            const btn = document.getElementById('notesToggle');
            btn.textContent = notesVisible ? 'Hide Notes 🙈' : 'Show Notes 👁️';
            
            // Update all cells with notes
            const cells = document.querySelectorAll('.cell.notes');
            cells.forEach(cell => {
                if (notesVisible) {
                    cell.classList.remove('notes-hidden');
                } else {
                    cell.classList.add('notes-hidden');
                }
            });
        }

        // Handle cell click (reveal cell)
        function onCellClick(e) {
            if (isComplete) return;
            
            const index = parseInt(e.target.dataset.index);
            const row = Math.floor(index / 9);
            const col = index % 9;
            
            if (gameGrid[row][col].revealed) {
                console.log(`ℹ️ Cell [${row},${col}] already revealed`);
                return;
            }
            
            // Reveal this cell
            revealCell(row, col);
        }

        // Reveal cell (like minesweeper)
        function revealCell(row, col) {
            console.log(`🎯 Revealing cell [${row},${col}]`);
            
            const correctValue = solution[row][col];
            gameGrid[row][col].value = correctValue;
            gameGrid[row][col].revealed = true;
            gameGrid[row][col].hintUsed = true;
            gameGrid[row][col].notes.clear();
            
            // Update display
            const cell = document.querySelector(`[data-index="${row * 9 + col}"]`);
            cell.classList.remove('notes', 'notes-hidden'); // Remove notes class
            cell.innerHTML = ''; // Clear any note divs
            cell.textContent = numberToEmoji[correctValue];
            cell.style.backgroundColor = 'white';
            cell.classList.add('user-input', 'hint-used');
            cell.style.animation = 'pulse 0.3s';
            
            // Update stats
            hintsUsed++;
            score = Math.max(0, 1000 - (hintsUsed * 50)); // -50 points per click
            updateStats();
            
            console.log(`✅ Revealed ${numberToEmoji[correctValue]} at [${row},${col}], Clicks: ${hintsUsed}`);
            
            // Update auto notes for affected cells
            updateAutoNotes(row, col, correctValue);
            
            // Check completion
            checkCompletion();
        }

        // Initialize auto notes
        function initializeAutoNotes() {
            console.log('🤖 Initializing auto-notes...');
            
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (!gameGrid[r][c].given && gameGrid[r][c].value === 0) {
                        gameGrid[r][c].notes.clear();
                        for (let num = 1; num <= 9; num++) {
                            if (isValidMove(r, c, num)) {
                                gameGrid[r][c].notes.add(num);
                            }
                        }
                        const cell = document.querySelector(`[data-index="${r * 9 + c}"]`);
                        updateCellDisplay(cell, r, c);
                    }
                }
            }
            
            console.log('✅ Auto-notes initialized');
            
            // Start the helper chain
            setTimeout(() => checkAndRemoveLockedCandidates(), intervalDuration);
        }

        // Check if move is valid
        function isValidMove(row, col, num) {
            // Check row
            for (let c = 0; c < 9; c++) {
                if (gameGrid[row][c].value === num) return false;
            }
            
            // Check column
            for (let r = 0; r < 9; r++) {
                if (gameGrid[r][col].value === num) return false;
            }
            
            // Check box
            const boxRow = Math.floor(row / 3) * 3;
            const boxCol = Math.floor(col / 3) * 3;
            for (let r = boxRow; r < boxRow + 3; r++) {
                for (let c = boxCol; c < boxCol + 3; c++) {
                    if (gameGrid[r][c].value === num) return false;
                }
            }
            
            return true;
        }

        // Update auto notes after placement
        function updateAutoNotes(placedRow, placedCol, placedNum) {
            console.log(`🔄 Updating auto-notes after placing ${numberToEmoji[placedNum]} at [${placedRow},${placedCol}]`);
            
            // Remove from row
            for (let c = 0; c < 9; c++) {
                if (c !== placedCol && gameGrid[placedRow][c].notes.has(placedNum)) {
                    gameGrid[placedRow][c].notes.delete(placedNum);
                    const cell = document.querySelector(`[data-index="${placedRow * 9 + c}"]`);
                    updateCellDisplay(cell, placedRow, c);
                }
            }
            
            // Remove from column
            for (let r = 0; r < 9; r++) {
                if (r !== placedRow && gameGrid[r][placedCol].notes.has(placedNum)) {
                    gameGrid[r][placedCol].notes.delete(placedNum);
                    const cell = document.querySelector(`[data-index="${r * 9 + placedCol}"]`);
                    updateCellDisplay(cell, r, placedCol);
                }
            }
            
            // Remove from box
            const boxRow = Math.floor(placedRow / 3) * 3;
            const boxCol = Math.floor(placedCol / 3) * 3;
            for (let r = boxRow; r < boxRow + 3; r++) {
                for (let c = boxCol; c < boxCol + 3; c++) {
                    if ((r !== placedRow || c !== placedCol) && gameGrid[r][c].notes.has(placedNum)) {
                        gameGrid[r][c].notes.delete(placedNum);
                        const cell = document.querySelector(`[data-index="${r * 9 + c}"]`);
                        updateCellDisplay(cell, r, c);
                    }
                }
            }
            
            // Trigger helper chain
            setTimeout(() => checkAndRemoveLockedCandidates(), intervalDuration);
        }

        // Check and fill singles (naked singles)
        function checkAndFillSingles() {
            console.log('🔍 Checking for naked singles...');
            let filledAny = false;
            
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (gameGrid[r][c].value === 0 && gameGrid[r][c].notes.size === 1) {
                        const num = Array.from(gameGrid[r][c].notes)[0];
                        
                        console.log(`✨ Found naked single: ${numberToEmoji[num]} at [${r},${c}]`);
                        
                        gameGrid[r][c].value = num;
                        gameGrid[r][c].notes.clear();
                        
                        const cell = document.querySelector(`[data-index="${r * 9 + c}"]`);
                        cell.classList.remove('notes', 'notes-hidden');
                        cell.innerHTML = '';
                        cell.textContent = numberToEmoji[num];
                        cell.style.backgroundColor = 'white';
                        cell.classList.add('user-input', 'auto-filled');
                        
                        cell.style.animation = `pulse ${animationDuration}ms`;
                        setTimeout(() => {
                            cell.style.animation = '';
                            cell.classList.remove('auto-filled');
                        }, animationDuration);
                        
                        updateAutoNotes(r, c, num);
                        filledAny = true;
                    }
                }
            }
            
            if (filledAny) {
                checkCompletion();
                setTimeout(() => checkAndFillSingles(), intervalDuration);
            } else {
                setTimeout(() => checkAndFillHiddenSingles(), intervalDuration);
            }
        }

        // Check and fill hidden singles
        function checkAndFillHiddenSingles() {
            console.log('🔍 Checking for hidden singles...');
            let filledAny = false;
            
            // Check rows
            for (let row = 0; row < 9; row++) {
                for (let num = 1; num <= 9; num++) {
                    let exists = false;
                    for (let col = 0; col < 9; col++) {
                        if (gameGrid[row][col].value === num) {
                            exists = true;
                            break;
                        }
                    }
                    if (exists) continue;
                    
                    const possiblePositions = [];
                    for (let col = 0; col < 9; col++) {
                        if (gameGrid[row][col].value === 0 && gameGrid[row][col].notes.has(num)) {
                            possiblePositions.push(col);
                        }
                    }
                    
                    if (possiblePositions.length === 1) {
                        const col = possiblePositions[0];
                        console.log(`✨ Found hidden single (row): ${numberToEmoji[num]} at [${row},${col}]`);
                        autoFillCell(row, col, num, 'row');
                        filledAny = true;
                    }
                }
            }
            
            // Check columns
            for (let col = 0; col < 9; col++) {
                for (let num = 1; num <= 9; num++) {
                    let exists = false;
                    for (let row = 0; row < 9; row++) {
                        if (gameGrid[row][col].value === num) {
                            exists = true;
                            break;
                        }
                    }
                    if (exists) continue;
                    
                    const possiblePositions = [];
                    for (let row = 0; row < 9; row++) {
                        if (gameGrid[row][col].value === 0 && gameGrid[row][col].notes.has(num)) {
                            possiblePositions.push(row);
                        }
                    }
                    
                    if (possiblePositions.length === 1) {
                        const row = possiblePositions[0];
                        if (gameGrid[row][col].value === 0) {
                            console.log(`✨ Found hidden single (column): ${numberToEmoji[num]} at [${row},${col}]`);
                            autoFillCell(row, col, num, 'column');
                            filledAny = true;
                        }
                    }
                }
            }
            
            // Check boxes
            for (let boxRow = 0; boxRow < 3; boxRow++) {
                for (let boxCol = 0; boxCol < 3; boxCol++) {
                    for (let num = 1; num <= 9; num++) {
                        let exists = false;
                        const startRow = boxRow * 3;
                        const startCol = boxCol * 3;
                        
                        for (let r = startRow; r < startRow + 3; r++) {
                            for (let c = startCol; c < startCol + 3; c++) {
                                if (gameGrid[r][c].value === num) {
                                    exists = true;
                                    break;
                                }
                            }
                            if (exists) break;
                        }
                        if (exists) continue;
                        
                        const possiblePositions = [];
                        for (let r = startRow; r < startRow + 3; r++) {
                            for (let c = startCol; c < startCol + 3; c++) {
                                if (gameGrid[r][c].value === 0 && gameGrid[r][c].notes.has(num)) {
                                    possiblePositions.push({row: r, col: c});
                                }
                            }
                        }
                        
                        if (possiblePositions.length === 1) {
                            const {row, col} = possiblePositions[0];
                            if (gameGrid[row][col].value === 0) {
                                console.log(`✨ Found hidden single (box): ${numberToEmoji[num]} at [${row},${col}]`);
                                autoFillCell(row, col, num, 'box');
                                filledAny = true;
                            }
                        }
                    }
                }
            }
            
            if (filledAny) {
                checkCompletion();
                setTimeout(() => checkAndFillSingles(), intervalDuration);
            } else {
                setTimeout(() => checkAndRemoveLockedCandidates(), intervalDuration);
            }
        }

        // Auto fill cell
        function autoFillCell(row, col, num, reason) {
            gameGrid[row][col].value = num;
            gameGrid[row][col].notes.clear();
            
            const cell = document.querySelector(`[data-index="${row * 9 + col}"]`);
            cell.classList.remove('notes', 'notes-hidden');
            cell.innerHTML = '';
            cell.textContent = numberToEmoji[num];
            cell.classList.add('user-input', 'auto-filled');
            
            const color = reason === 'row' ? '#4299e1' : reason === 'column' ? '#48bb78' : '#ed8936';
            cell.style.backgroundColor = color;
            cell.style.animation = `pulse ${animationDuration}ms`;
            setTimeout(() => {
                cell.style.animation = '';
                cell.style.backgroundColor = 'white'; // Keep white after animation
                cell.classList.remove('auto-filled');
            }, animationDuration);
            
            updateAutoNotes(row, col, num);
        }

        // Check and remove locked candidates
        function checkAndRemoveLockedCandidates() {
            console.log('🔍 Checking for locked candidates...');
            let removedAny = false;
            
            // Check pointing pairs/triples (box to line)
            for (let boxRow = 0; boxRow < 3; boxRow++) {
                for (let boxCol = 0; boxCol < 3; boxCol++) {
                    for (let num = 1; num <= 9; num++) {
                        const candidateCells = [];
                        const startRow = boxRow * 3;
                        const startCol = boxCol * 3;
                        
                        for (let r = startRow; r < startRow + 3; r++) {
                            for (let c = startCol; c < startCol + 3; c++) {
                                if (gameGrid[r][c].value === 0 && gameGrid[r][c].notes.has(num)) {
                                    candidateCells.push({row: r, col: c});
                                }
                            }
                        }
                        
                        if (candidateCells.length >= 2) {
                            // Check if all in same row
                            const firstRow = candidateCells[0].row;
                            if (candidateCells.every(cell => cell.row === firstRow)) {
                                for (let c = 0; c < 9; c++) {
                                    if (Math.floor(c / 3) !== boxCol) {
                                        if (gameGrid[firstRow][c].notes.has(num)) {
                                            gameGrid[firstRow][c].notes.delete(num);
                                            const cell = document.querySelector(`[data-index="${firstRow * 9 + c}"]`);
                                            updateCellDisplay(cell, firstRow, c);
                                            removedAny = true;
                                            console.log(`🚫 Removed ${numberToEmoji[num]} from [${firstRow},${c}] (row pointing)`);
                                            
                                            cell.style.backgroundColor = '#feb2b2';
                                            setTimeout(() => {
                                                cell.style.backgroundColor = '';
                                            }, animationDuration);
                                        }
                                    }
                                }
                            }
                            
                            // Check if all in same column
                            const firstCol = candidateCells[0].col;
                            if (candidateCells.every(cell => cell.col === firstCol)) {
                                for (let r = 0; r < 9; r++) {
                                    if (Math.floor(r / 3) !== boxRow) {
                                        if (gameGrid[r][firstCol].notes.has(num)) {
                                            gameGrid[r][firstCol].notes.delete(num);
                                            const cell = document.querySelector(`[data-index="${r * 9 + firstCol}"]`);
                                            updateCellDisplay(cell, r, firstCol);
                                            removedAny = true;
                                            console.log(`🚫 Removed ${numberToEmoji[num]} from [${r},${firstCol}] (column pointing)`);
                                            
                                            cell.style.backgroundColor = '#9ae6b4';
                                            setTimeout(() => {
                                                cell.style.backgroundColor = '';
                                            }, animationDuration);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            if (removedAny) {
                setTimeout(() => checkAndFillSingles(), intervalDuration);
            } else {
                // Continue the cycle
                setTimeout(() => checkAndFillSingles(), intervalDuration * 3);
            }
        }

        // Check completion
        function checkCompletion() {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (gameGrid[r][c].value === 0) return;
                }
            }
            
            // Puzzle complete!
            isComplete = true;
            clearInterval(timerInterval);
            showCompletionModal();
        }

        // Show completion modal
        function showCompletionModal() {
            const modal = document.getElementById('completionModal');
            const overlay = document.getElementById('modalOverlay');
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalHints').textContent = hintsUsed;
            
            let message = '';
            if (hintsUsed === 0) {
                message = '🌟 LEGENDARY! Perfect solve with no hints! 🌟';
            } else if (hintsUsed <= 5) {
                message = '🎯 Amazing! You have excellent Sudoku skills!';
            } else if (hintsUsed <= 10) {
                message = '👍 Great job! You solved it efficiently!';
            } else if (hintsUsed <= 20) {
                message = '😊 Good work! Keep practicing to use fewer hints!';
            } else {
                message = '✅ You did it! Try using fewer hints next time!';
            }
            
            document.getElementById('scoreMessage').textContent = message;
            
            modal.classList.add('show');
            overlay.classList.add('show');
        }

        // Close modal
        function closeModal() {
            document.getElementById('completionModal').classList.remove('show');
            document.getElementById('modalOverlay').classList.remove('show');
        }

        // Update stats display
        function updateStats() {
            document.getElementById('hintCount').textContent = hintsUsed;
            document.getElementById('score').textContent = score;
        }

        // Start timer
        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        // Update timer
        function updateTimer() {
            if (isComplete) return;
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // New game
        function newGame() {
            console.log('🎲 Starting new game...');
            
            // Reset state
            hintsUsed = 0;
            score = 1000;
            isComplete = false;
            
            // Clear timer
            if (timerInterval) clearInterval(timerInterval);
            
            // Update UI
            updateStats();
            closeModal();
            
            // Initialize new game
            initGame();
        }


        // Start the game
        window.onload = initGame;
    </script>
</body>
</html>